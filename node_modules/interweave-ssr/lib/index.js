'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperties(exports, {
  __esModule: {
    value: true
  },
  [Symbol.toStringTag]: {
    value: 'Module'
  }
});

const parse5 = require('parse5');

const adapter = require('parse5/lib/tree-adapters/default');

const parseStyle = require('style-parser');

const _interopDefault = e => e && e.__esModule ? e : {
  default: e
};

const adapter__default = /*#__PURE__*/_interopDefault(adapter);

const parseStyle__default = /*#__PURE__*/_interopDefault(parseStyle);
/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */


function patchTextNodeInChildren(parentNode) {
  parentNode.childNodes.forEach(node => {
    if (node.nodeName === '#text' && !node.textContent) {
      Object.defineProperties(node, {
        nodeType: {
          value: 3
        },
        textContent: {
          value: node.value,
          writable: true
        },
        value: {
          get() {
            return this.textContent;
          },

          set(value) {
            this.textContent = value;
          }

        }
      });
    }
  });
}

function createStyleDeclaration(decls) {
  const object = parseStyle__default.default(decls);
  const style = Object.keys(object);
  Object.assign(style, object);
  return style;
}

const treeAdapter = _objectSpread(_objectSpread({}, adapter__default.default), {}, {
  createCommentNode(data) {
    return _objectSpread(_objectSpread({}, adapter__default.default.createCommentNode(data)), {}, {
      nodeType: 8
    });
  },

  createElement(tagName, namespace, attrs) {
    let attributes = [...attrs];

    const element = _objectSpread(_objectSpread({}, adapter__default.default.createElement(tagName, namespace, attrs)), {}, {
      attributes,

      getAttribute(name) {
        const result = attributes.find(attr => attr.name === name);
        return result ? result.value : null;
      },

      hasAttribute(name) {
        return attributes.some(attr => attr.name === name);
      },

      nodeType: 1,
      protocol: '',

      removeAttribute(name) {
        attributes = attributes.filter(attr => attr.name !== name);
      },

      setAttribute(name, value) {
        const result = attributes.find(attr => attr.name === name);

        if (result) {
          result.value = value;
        } else {
          attributes.push({
            name,
            value
          });
        }
      },

      style: [],
      tagName,
      textContent: ''
    });

    const style = element.getAttribute('style');

    if (style) {
      element.style = createStyleDeclaration(style);
    }

    if (element.nodeName === 'a') {
      element.protocol = ':';
    }

    return element;
  },

  insertText(parentNode, text) {
    adapter__default.default.insertText(parentNode, text);
    patchTextNodeInChildren(parentNode);
  },

  insertTextBefore(parentNode, text, referenceNode) {
    adapter__default.default.insertTextBefore(parentNode, text, referenceNode);
    patchTextNodeInChildren(parentNode);
  }

});

function parseHTML(markup) {
  return parse5.parse(markup, {
    treeAdapter
  });
}

function createHTMLDocument() {
  const doc = parseHTML('<!DOCTYPE html><html><head></head><body></body></html>');
  const html = doc.childNodes[1];
  const body = html.childNodes[1];
  Object.defineProperty(html, 'body', {
    value: body
  });
  Object.defineProperty(body, 'innerHTML', {
    set(value) {
      var _parseHTML$childNodes, _parseHTML$childNodes2;

      // #document -> html -> body -> tag
      // @ts-expect-error Allow types
      this.childNodes = (_parseHTML$childNodes = parseHTML(String(value)).childNodes[0]) === null || _parseHTML$childNodes === void 0 ? void 0 : (_parseHTML$childNodes2 = _parseHTML$childNodes.childNodes[1]) === null || _parseHTML$childNodes2 === void 0 ? void 0 : _parseHTML$childNodes2.childNodes;
    }

  });
  return html;
}

function polyfill() {
  global.INTERWEAVE_SSR_POLYFILL = createHTMLDocument;
}

exports.polyfill = polyfill;
//# sourceMappingURL=index.js.map
